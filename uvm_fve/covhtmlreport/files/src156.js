var g_data = {"name":"../rtl/./timer_fvs.vhd","src":"library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity timer is\n    generic(\n        ADDR_WIDTH      : natural              := 32;\n        DATA_WIDTH      : natural              := 32;\n        TIMER_ADDR_SPACE_BITS : natural        :=  8; -- Registers address space size bit width\n        RST_ACT_LEVEL   : natural range 0 to 1 :=  1\n    );\n    port (\n        CLK               : in  std_logic;\n        RST               : in  std_logic;\n        REQUEST           : in  std_logic_vector(1 downto 0);\n        ADDRESS           : in  std_logic_vector(ADDR_WIDTH -1 downto 0);\n        DATA_IN           : in  std_logic_vector(DATA_WIDTH- 1 downto 0);\n        RESPONSE          : out std_logic_vector( 2 downto 0); \n        DATA_OUT          : out std_logic_vector(DATA_WIDTH -1 downto 0);\n        P_IRQ             : out std_logic\n    );\nend entity timer;\n\narchitecture RTL of timer is\n\n    -- request command constants\n    constant CP_REQ_NONE           : unsigned(1 downto 0) := \"00\";\n    constant CP_REQ_READ           : unsigned(1 downto 0) := \"01\";\n    constant CP_REQ_WRITE          : unsigned(1 downto 0) := \"10\";\n    constant CP_REQ_RESERVED       : unsigned(1 downto 0) := \"11\";\n    \n    -- command response constants\n    constant CP_RSP_IDLE           : unsigned(2 downto 0) := \"000\";\n    constant CP_RSP_ACK            : unsigned(2 downto 0) := \"001\";\n    constant CP_RSP_WAIT           : unsigned(2 downto 0) := \"010\";\n    constant CP_RSP_ERROR          : unsigned(2 downto 0) := \"011\";\n    constant CP_RSP_UNALIGNED      : unsigned(2 downto 0) := \"100\";\n    constant CP_RSP_OOR            : unsigned(2 downto 0) := \"101\";\n    \n    ----------------------------------------------------------------------------------\n    -- signals and registers\n    signal re_d, re_q                       : std_logic;\n    signal we_d, we_q                       : std_logic;\n    signal bus_data_rd                      : std_logic_vector(DATA_WIDTH - 1 downto 0);\n    signal bus_data_wr_d                    : std_logic_vector(DATA_WIDTH - 1 downto 0);\n    signal bus_data_wr_q                    : std_logic_vector(DATA_WIDTH - 1 downto 0);\n    signal bus_addr_d, bus_addr_q           : std_logic_vector( TIMER_ADDR_SPACE_BITS - 1 downto 0);\n    signal bus_resp, bus_resp_d, bus_resp_q : unsigned(2 downto 0);\n\n    ----------------------------------------------------------------------------------\n    -- timer registers address constants\n    constant TIMER_CNT     : std_logic_vector(TIMER_ADDR_SPACE_BITS - 1 downto 0) := X\"00\"; -- Timer Count Register, read/write\n    constant TIMER_CMP     : std_logic_vector(TIMER_ADDR_SPACE_BITS - 1 downto 0) := X\"04\"; -- Timer Compare Register, read/write\n    constant TIMER_CR      : std_logic_vector(TIMER_ADDR_SPACE_BITS - 1 downto 0) := X\"08\"; -- Timer Control Register, read/write\n    constant TIMER_CYCLE_L : std_logic_vector(TIMER_ADDR_SPACE_BITS - 1 downto 0) := X\"10\"; -- 64b Cycle Counter, low word, read-only\n    constant TIMER_CYCLE_H : std_logic_vector(TIMER_ADDR_SPACE_BITS - 1 downto 0) := X\"14\"; -- 64b Cycle Counter, high word, read-only\n\n    ----------------------------------------------------------------------------------\n    -- timer modes\n    constant DISABLED     : std_logic_vector(1 downto 0) := \"00\";\n    constant AUTO_RESTART : std_logic_vector(1 downto 0) := \"01\";\n    constant ONE_SHOT     : std_logic_vector(1 downto 0) := \"10\";\n    constant CONTINUOUS   : std_logic_vector(1 downto 0) := \"11\"; \n    \n    ---------------------------------------------------------------------------------\n    -- timer specific registers\n    signal cnt_reg_q, cnt_reg_d  : unsigned(31 downto 0);\n    signal cmp_reg_q, cmp_reg_d  : unsigned(31 downto 0);\n    signal ctrl_reg_q, ctrl_reg_d : std_logic_vector(1 downto 0);   \n\n    -- 64b cycle counter\n    signal cycle_cnt : unsigned(63 downto 0);\n    \n    -- Reset signal value\n    constant RST_LEVEL    : std_logic := to_unsigned(RST_ACT_LEVEL, 1)(0);\n\nbegin\n\n    ----------------------------------------------------------------------------------\n    -- setting of response\n    -- considering requests: read, write\n    -- address range checked during request phase\n    -- address must be aligned to 32b words\n    -- bus_resp_d <=\n    --     CP_RSP_IDLE     when ((unsigned(REQUEST) /= CP_REQ_READ) and \n    --                           (unsigned(REQUEST) /= CP_REQ_WRITE)) else\n    --     CP_RSP_ERROR     when (unsigned(REQUEST) = CP_REQ_RESERVED) else\n    --     CP_RSP_UNALIGNED when (ADDRESS(1 downto 0) /= \"00\") else\n    --     CP_RSP_OOR       when (unsigned(ADDRESS(ADDR_WIDTH - 1 downto TIMER_ADDR_SPACE_BITS)) /= 0) else \n    --     CP_RSP_ACK;\n    \n    -- corrected\n    bus_resp_d <=\n    CP_RSP_IDLE      when unsigned(REQUEST) = CP_REQ_NONE       else\n    CP_RSP_ERROR     when unsigned(REQUEST) = CP_REQ_RESERVED   else\n    CP_RSP_OOR       when unsigned(\n                        ADDRESS(TIMER_ADDR_SPACE_BITS-1 downto 0)\n                      ) > unsigned(TIMER_CYCLE_H)               else\n    CP_RSP_UNALIGNED when ADDRESS(1 downto 0) /= \"00\"            else\n    CP_RSP_ACK;\n\n    ----------------------------------------------------------------------------------\n    -- setting of help signals\n    re_d        <= \'1\' when (unsigned(REQUEST) = CP_REQ_READ)  and (bus_resp_d = CP_RSP_ACK) else \'0\';\n    we_d        <= \'1\' when (unsigned(REQUEST) = CP_REQ_WRITE) and (bus_resp_d = CP_RSP_ACK) else \'0\';\n    bus_addr_d  <= ADDRESS(TIMER_ADDR_SPACE_BITS - 1 downto 0) when ((re_d = \'1\') or (we_d = \'1\')) else bus_addr_q;\n    bus_data_wr_d <= DATA_IN;\n\n    ----------------------------------------------------------------------------------\n    -- setting of help signals\n    process (CLK, RST) begin\n        if (RST = \'0\') then\n            re_q       <= \'0\';\n            we_q       <= \'0\';\n            bus_resp_q <= CP_RSP_IDLE;\n            bus_addr_q <= (others => \'0\');\n            bus_data_wr_q <= (others => \'0\');\n        elsif rising_edge(CLK) then\n            re_q       <= re_d;\n            we_q       <= we_d;\n            bus_resp_q <= bus_resp_d;\n            bus_addr_q <= bus_addr_d;\n            bus_data_wr_q <= bus_data_wr_d;\n        end if;\n    end process;\n\n    ----------------------------------------------------------------------------------\n    -- setting of timer registers\n    process (CLK, RST) begin\n        if (RST = \'0\') then\n            cnt_reg_q  <= (others => \'0\');\n            cmp_reg_q  <= (others => \'0\');\n            ctrl_reg_q <= (others => \'0\');\n        elsif rising_edge(CLK) then\n            cnt_reg_q  <= cnt_reg_d;\n            cmp_reg_q  <= cmp_reg_d;\n            ctrl_reg_q <= ctrl_reg_d;\n        end if;\n    end process;\n\n    -- 64b cycle counter\n    process (CLK, RST) begin\n        if rising_edge(clk) then\n            if (RST = RST_LEVEL)   then\n                cycle_cnt <= (others => \'0\');\n            else\n                cycle_cnt <= cycle_cnt + 1;\n            end if;\n        end if;\n    end process;\n\n    ----------------------------------------------------------------------------------\n    -- next state logic for peripheral registers\n    process (we_q, re_q, bus_addr_q, bus_data_wr_q, cnt_reg_q, cmp_reg_q, ctrl_reg_q, cycle_cnt) begin\n        cnt_reg_d   <= cnt_reg_q;\n        cmp_reg_d   <= cmp_reg_q;\n        ctrl_reg_d  <= ctrl_reg_q;\n\n        bus_data_rd <= (others => \'0\');\n        bus_resp    <= CP_RSP_IDLE;\n\n        -- counting \n        case ctrl_reg_q is\n            -- incrementing cnt_reg, if value in cmp_reg reached then restart of cnt_reg from 0\n            when AUTO_RESTART =>\n                if (cnt_reg_q = cmp_reg_q) then\n                    cnt_reg_d  <= (others => \'0\');\n                else\n                    cnt_reg_d  <= cnt_reg_q + 1;\n                end if;\n            -- incrementing cnt_reg, if value in cmp_reg reached then disabling of the counter\n            when ONE_SHOT     =>\n                if (cnt_reg_q = cmp_reg_q) then\n                    cnt_reg_d  <= (others => \'0\');\n                    ctrl_reg_d <= (others => \'0\');\n                else\n                    cnt_reg_d  <= cnt_reg_q + 1;\n                end if;\n            -- continuos counting\n            when CONTINUOUS   =>\n                cnt_reg_d  <= cnt_reg_q + 1;\n            -- disabling counter\n            when DISABLED     =>\n                    null;\n            when others       =>\n                    null;\n        end case;\n        \n        -- read/write data from/to peripheral registers\n        -- read\n        if (re_q = \'1\') then                    \n            -- read value of counter register\n            if (bus_addr_q = TIMER_CNT) then              \n                bus_data_rd <= std_logic_vector(resize(unsigned(cnt_reg_q), DATA_WIDTH));\n                bus_resp    <= CP_RSP_ACK;\n            -- read value of compare register\n            elsif (bus_addr_q = TIMER_CMP) then  \n                bus_data_rd <= std_logic_vector(resize(unsigned(cmp_reg_q), DATA_WIDTH));\n                bus_resp    <= CP_RSP_ACK;\n            -- read value of control register\n            elsif (bus_addr_q = TIMER_CR) then                \n                bus_data_rd <= std_logic_vector(resize(unsigned(ctrl_reg_q), DATA_WIDTH));\n                bus_resp    <= CP_RSP_ACK;\n            -- read value of 64b Cycle Counter, low word\n            elsif (bus_addr_q = TIMER_CYCLE_L) then          \n                bus_data_rd <= std_logic_vector(cycle_cnt(31 downto 0));\n                bus_resp    <= CP_RSP_ACK;\n            -- read value of 64b Cycle Counter, high word\n            elsif (bus_addr_q = TIMER_CYCLE_H) then          \n                bus_data_rd <= std_logic_vector(cycle_cnt(63 downto 32));\n                bus_resp    <= CP_RSP_ACK;\n            else\n                bus_resp    <= CP_RSP_ACK;\n            end if;\n        -- write\n        elsif (we_q = \'1\') then             \n            -- write value of new counter - to the counter register\n            if (bus_addr_q = TIMER_CNT) then              \n                cnt_reg_d  <= unsigned(bus_data_wr_q);\n                bus_resp   <= CP_RSP_ACK;\n            -- write value to which the counter will be compared - to compare register\n            elsif (bus_addr_q = TIMER_CMP) then              \n                cmp_reg_d <= unsigned(bus_data_wr_q);\n                bus_resp   <= CP_RSP_ACK;\n            -- write value to control register which determines the operation of timer\n            elsif (bus_addr_q = TIMER_CR)  then                \n                ctrl_reg_d <= bus_data_wr_q(1 downto 0);\n                bus_resp   <= CP_RSP_ACK;\n            else\n                bus_resp   <= CP_RSP_ACK;\n            end if;\n        end if;\n    end process;\n\n    ----------------------------------------------------------------------------------\n    -- setting outputs\n    RESPONSE <= std_logic_vector(bus_resp) when (bus_resp_q = CP_RSP_ACK) else std_logic_vector(bus_resp_q);\n    DATA_OUT <= bus_data_rd;\n\n    ----------------------------------------------------------------------------------\n    -- setting outputs interrupt signal\n    P_IRQ <= \'1\' when (ctrl_reg_q /= DISABLED) and (cnt_reg_q = cmp_reg_q) else \'0\'; \n\nend architecture RTL;\n","lang":"vhdl"};
processSrcData(g_data);
var g_data = {"name":"abv/./abv_timer.sv","src":"`include \"uvm_macros.svh\"\nimport uvm_pkg::*;\nimport sv_param_pkg::*;\n\nmodule abv_timer (\n    input logic                  CLK,\n    input logic                  RST,\n    input logic                  P_IRQ,\n    input logic [ADDR_WIDTH-1:0] ADDRESS,\n    input logic [1:0]            REQUEST,\n    input logic [2:0]            RESPONSE,\n    input logic [DATA_WIDTH-1:0] DATA_OUT,\n    input logic [DATA_WIDTH-1:0] DATA_IN,\n    input logic [1:0]            ctrl_reg_d,\n    input logic [DATA_WIDTH-1:0] cnt_reg_d,\n    input logic [DATA_WIDTH-1:0] cmp_reg_d,\n    input logic [63:0]           cycle_cnt\n);\n\nproperty asyncRegZeroWhenReset;\n    @(posedge CLK) RST === RST_ACT_LEVEL |-> (\n        ctrl_reg_d === TIMER_CR_DISABLED &&\n        cnt_reg_d  === 0 &&\n        cmp_reg_d  === 0\n    );\nendproperty\n\nproperty cyclecntRegZeroWhenReset;\n    @(posedge CLK) RST === RST_ACT_LEVEL |=> cnt_reg_d  === 0;\nendproperty\n\nproperty addrOORResponse;\n    @(posedge CLK)\n    disable iff ($isunknown(RST) || RST === RST_ACT_LEVEL)\n    (ADDRESS > 8\'h14) |-> ##1 (RESPONSE === CP_RSP_OOR);\nendproperty\n\nproperty signalsKnownInactiveReset;\n    @(posedge CLK)\n    disable iff ($isunknown(RST) || RST === RST_ACT_LEVEL)\n    (!$isunknown(ADDRESS) &&\n     !$isunknown(REQUEST) &&\n     !$isunknown(RESPONSE) &&\n     !$isunknown(P_IRQ)\n    );\nendproperty\n\nproperty prUnknownDataRead;\n    @(posedge CLK) (REQUEST === CP_REQ_READ)\n        |=> (!$isunknown((DATA_IN))) && (!$isunknown((DATA_OUT)));\nendproperty\n\nproperty prUnknownDataWrite;\n    @(posedge CLK) (REQUEST === CP_REQ_WRITE)\n        |-> (!$isunknown((DATA_IN))) && (!$isunknown((DATA_OUT)));\nendproperty\n\n// OOR has priority over UNALIGNED\nproperty prReadWriteOOR;\n     @(posedge CLK)\n     disable iff ($isunknown(RST) || RST === RST_ACT_LEVEL)\n     (REQUEST === CP_REQ_READ || REQUEST === CP_REQ_WRITE) && (ADDRESS > 8\'h14)\n        |-> ##1 (RESPONSE === CP_RSP_OOR);\nendproperty\n\n// does not apply if the address is OOR\nproperty prReadWriteUnaligned;\n     @(posedge CLK)\n     disable iff ($isunknown(RST) || RST === RST_ACT_LEVEL)\n     (REQUEST === CP_REQ_READ || REQUEST === CP_REQ_WRITE) && (ADDRESS <= 8\'h14) && (ADDRESS[1:0] != 2\'b00)\n        |-> ##1 (RESPONSE === CP_RSP_UNALIGNED);\nendproperty\nproperty checkWriteReadSameAddr;\n  logic [ADDR_WIDTH-1:0] v_addr;\n  logic [DATA_WIDTH-1:0] v_data;\n\n  @(posedge CLK)\n  disable iff ($isunknown(RST) || RST === RST_ACT_LEVEL)\n    // 1) write cycle: RST must be known & inactive\n    (REQUEST == CP_REQ_WRITE\n       && (ADDRESS == TIMER_CNT || ADDRESS == TIMER_CMP || \n          (ADDRESS == TIMER_CR && DATA_IN <= TIMER_CR_CONTINUOUS)),\n     v_addr  = ADDRESS,\n     v_data  = DATA_IN)\n    // 2) read cycle: again RST known & inactive\n    ##1 (\n      REQUEST == CP_REQ_READ\n      && ADDRESS == v_addr\n    )\n  // 3) dataâ€out check one cycle later: still RST known & inactive\n  |-> ##1 (\n      DATA_OUT == v_data\n    );\nendproperty\n\n// does not apply if the address is OOR or UNALIGNED\nproperty ackAfterCorrectAddr;\n    @(posedge CLK)\n    disable iff ($isunknown(RST) || RST === RST_ACT_LEVEL)\n    ( (REQUEST === CP_REQ_READ || REQUEST === CP_REQ_WRITE) && ADDRESS <= 8\'h14 && ADDRESS[1:0] === 2\'b00)\n    |-> ##1\n    ( RESPONSE === CP_RSP_ACK );\nendproperty\n\nproperty idleResponseToNonReq;\n    @(posedge CLK)\n    ( (REQUEST === CP_REQ_NONE) )\n    |-> ##1\n    ( RESPONSE === CP_RSP_IDLE );\nendproperty\n\nproperty errorResponseToResReq;\n    @(posedge CLK)\n    disable iff ($isunknown(RST) || RST === RST_ACT_LEVEL)\n    ( (REQUEST === CP_REQ_RESERVED) )\n    |-> ##1\n    ( RESPONSE === CP_RSP_ERROR );\nendproperty\n\n// this should never ever happen\nproperty noWaitResponse;\n    @(posedge CLK) (RST === !RST_ACT_LEVEL) |-> !(RESPONSE === CP_RSP_WAIT);\nendproperty\n\nproperty irqAfterCmpCntMatch;\n    @(posedge CLK)\n    disable iff ($isunknown(RST) || RST === RST_ACT_LEVEL)\n    ((ctrl_reg_d != TIMER_CR_DISABLED) && (cnt_reg_d === cmp_reg_d))\n        |-> ##1 (P_IRQ === 1);\nendproperty\n\n// does not apply if we change the mode during IRQ\nproperty clearCntAfterCmpCntMatchAutoRestart;\n    @(posedge CLK) ((cnt_reg_d === cmp_reg_d) && (ctrl_reg_d === TIMER_CR_AUTO_RESTART)\n        && !((REQUEST == CP_REQ_WRITE && DATA_IN != TIMER_CR_DISABLED)))\n        |-> ##1 ( cnt_reg_d === 0 );\nendproperty\n\n// does not apply if:\n//      we are changing mode\n//      OR we are writing another value to CNT\nproperty incCntAfterCmpCntMatchContinuous;\n    @(posedge CLK)\n    disable iff ($isunknown(RST) || RST === RST_ACT_LEVEL)\n    ((cnt_reg_d === cmp_reg_d) && (ctrl_reg_d === TIMER_CR_CONTINUOUS)\n        && !((REQUEST == CP_REQ_WRITE && ADDRESS == TIMER_CR && DATA_IN != TIMER_CR_DISABLED) || (REQUEST == CP_REQ_WRITE && ADDRESS == TIMER_CNT)) )\n        |-> ##1 ( cnt_reg_d === $past(cnt_reg_d) + 1 );\nendproperty\n\n// does not apply in cornercase\nproperty clearCntDisAfterCmpCntMatchOneShot;\n    @(posedge CLK) ((cnt_reg_d === cmp_reg_d) && (ctrl_reg_d === TIMER_CR_ONESHOT)\n        && !(REQUEST == CP_REQ_WRITE && DATA_IN != TIMER_CR_DISABLED))\n        |-> ##1 (cnt_reg_d === 0 && ctrl_reg_d === TIMER_CR_DISABLED);\nendproperty\n\n// must be the current clock value\nproperty cycleLRead;\n    @(posedge CLK)\n    disable iff ($isunknown(RST) || RST === RST_ACT_LEVEL)\n    (ADDRESS === TIMER_CYCLE_L && REQUEST === CP_REQ_READ)\n        |-> ##1 (DATA_OUT === cycle_cnt[31:0]);\nendproperty\n\n// must be the current clock value\nproperty cycleHRead;\n    @(posedge CLK)\n    disable iff ($isunknown(RST) || RST === RST_ACT_LEVEL)\n    (ADDRESS === TIMER_CYCLE_H && REQUEST === CP_REQ_READ)\n        |-> ##1 (DATA_OUT === cycle_cnt[63:32]);\nendproperty\n\n// must be synchronous\nproperty cycleCntZeroDuringReset;\n    @(posedge CLK) (RST === RST_ACT_LEVEL)\n        |-> ##1 (cycle_cnt === 0);\nendproperty\n\n// --- Assertions and Covers ---\n\na_ResetRegCheck: assert property (asyncRegZeroWhenReset)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion asyncRegZeroWhenReset FAILED: registers not resetting asynchronously with RST.\")\n    end\n\na_ResetCycleCntRegCheck: assert property (cyclecntRegZeroWhenReset)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion cyclecntRegZeroWhenReset FAILED: cycle cnt not resetting synchronously with RST.\")\n    end\n\n// --- asserts and covers from LAB4 ---\n\na_addrOORResponseCheck: assert property (addrOORResponse)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", $sformatf(\"Assertion addrOORResponse FAILED: OOR Address 0x%0h did not trigger OOR response (RESPONSE = %0d).\", ADDRESS, RESPONSE))\n    end\n\na_signalsKnownInactiveResetCheck: assert property(signalsKnownInactiveReset)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion signalsKnownInactiveReset FAILED: ADDRESS, REQUEST, RESPONSE, P_IRQ are unknown with inactive RST.\")\n    end\n\n// a   prUnknownDataRead\na_prUnknownDataRead: assert property (prUnknownDataRead)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion prUnknownDataRead FAILED: DATA_IN or DATA_OUT has undefined values during reading.\")\n    end\n\n// a   prUnknownDataWrite\na_prUnknownDataWrite: assert property (prUnknownDataWrite)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion prUnknownDataWrite FAILED: DATA_IN or DATA_OUT has undefined values during writing.\")\n    end\n\n// a+c prReadWriteOOR\na_prReadWriteOOR: assert property (prReadWriteOOR)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion prReadWriteOOR FAILED: Writing or reading out of the allowed address range did not cause OOR response.\")\n    end\n\nc_prReadWriteOOR: cover property (prReadWriteOOR);\n\n// a+c prReadWriteUnaligned\na_prReadWriteUnaligned: assert property (prReadWriteUnaligned)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion prReadWriteUnaligned FAILED: Writing or reading to/from unaligned address did not cause UNALIGNED response.\")\n    end\n\nc_prReadWriteUnaligned: cover property (prReadWriteUnaligned);\n\n// a+c checkWriteReadSameAddr\na_checkWriteReadSameAddr: assert property (checkWriteReadSameAddr)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion checkWriteReadSameAddr FAILED: Read did not read fresh data after writing them in the previous clock.\")\n    end\n\nc_checkWriteReadSameAddr: cover property (checkWriteReadSameAddr);\n\n// a+c ackAfterCorrectAddr\na_ackAfterCorrectAddr: assert property (ackAfterCorrectAddr)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion ackAfterCorrectAddr FAILED: No ACK response after a valid address read/write.\")\n    end\n\nc_ackAfterCorrectAddr: cover property (ackAfterCorrectAddr);\n\n// a+c idleResponseToNonReq\na_idleResponseToNonReq: assert property (idleResponseToNonReq)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion idleResponseToNonReq FAILED: No IDLE response to NONE request.\")\n    end\n\nc_idleResponseToNonReq: cover property (idleResponseToNonReq);\n\n// a+c errorResponseToResReq\na_errorResponseToResReq: assert property (errorResponseToResReq)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion errorResponseToResReq FAILED: No ERROR response to RESERVED request.\")\n    end\n\nc_errorResponseToResReq: cover property (errorResponseToResReq);\n\n// a   noWaitResponse\na_noWaitResponse: assert property (noWaitResponse)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion noWaitResponse FAILED: There should not be any WAIT response (ever).\")\n    end\n\n// a+c irqAfterCmpCntMatch\na_irqAfterCmpCntMatch: assert property (irqAfterCmpCntMatch)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion irqAfterCmpCntMatch FAILED: IRQ should be (active) for exactly one clock after cmp_reg == cnt_reg match.\")\n    end\n\nc_irqAfterCmpCntMatch: cover property (irqAfterCmpCntMatch);\n\n// a+c clearCntAfterCmpCntMatchAutoRestart\na_clearCntAfterCmpCntMatchAutoRestart: assert property (clearCntAfterCmpCntMatchAutoRestart)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion clearCntAfterCmpCntMatchAutoRestart FAILED: cnt_reg did not reset after IRQ in AUTO_RESTART mode.\")\n    end\n\nc_clearCntAfterCmpCntMatchAutoRestart: cover property (clearCntAfterCmpCntMatchAutoRestart);\n\n// a+c incCntAfterCmpCntMatchContinuous\na_incCntAfterCmpCntMatchContinuous: assert property (incCntAfterCmpCntMatchContinuous)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion incCntAfterCmpCntMatchContinuous FAILED: cnt_reg did not increment after IRQ in CONTINUOUS mode.\")\n    end\n\nc_incCntAfterCmpCntMatchContinuous: cover property (incCntAfterCmpCntMatchContinuous);\n\n// a+c clearCntDisAfterCmpCntMatchOneShot\na_clearCntDisAfterCmpCntMatchOneShot: assert property (clearCntDisAfterCmpCntMatchOneShot)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion clearCntDisAfterCmpCntMatchOneShot FAILED: cnt_reg did not reset OR the mode was not set to DISABLED after IRQ in ONE_SHOT mode.\")\n    end\nc_clearCntDisAfterCmpCntMatchOneShot: cover property (clearCntDisAfterCmpCntMatchOneShot);\n\n// a+c cycleLRead\na_cycleLRead: assert property (cycleLRead)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion cycleLRead FAILED: cycle_l read did not return valid current clock value.\")\n    end\n\nc_cycleLRead: cover property (cycleLRead);\n\n// a+c cycleHRead\na_cycleHRead: assert property (cycleHRead)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion cycleLRead FAILED: cycle_h read did not return valid current clock value.\")\n    end\n\nc_cycleHRead: cover property (cycleHRead);\n\n// a+c cycleCntZeroDuringReset\na_cycleCntZeroDuringReset: assert property (cycleCntZeroDuringReset)\nelse\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion cycleCntZeroDuringReset FAILED: cycle_cnt did not reset synchronously with RST signal.\")\n    end\n\nc_cycleCntZeroDuringReset: cover property (cycleCntZeroDuringReset);\nendmodule : abv_timer\n","lang":"verilog"};
processSrcData(g_data);
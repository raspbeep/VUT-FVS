var g_data = {"name":"abv/./abv_timer.sv","src":"`include \"uvm_macros.svh\"\nimport uvm_pkg::*;\nimport sv_param_pkg::*;\n\nmodule abv_timer (\n    input logic                  CLK,\n    input logic                  RST,\n    input logic                  P_IRQ,\n    input logic [ADDR_WIDTH-1:0] ADDRESS,\n    input logic [1:0]            REQUEST,\n    input logic [2:0]            RESPONSE,\n    input logic [DATA_WIDTH-1:0] DATA_OUT,\n    input logic [DATA_WIDTH-1:0] DATA_IN,\n    input logic [1:0]            ctrl_reg_d,\n    input logic [DATA_WIDTH-1:0] cnt_reg_d,\n    input logic [DATA_WIDTH-1:0] cmp_reg_d,\n    input logic [63:0]           cycle_cnt\n);\n\n// default disable iff (RST === RST_ACT_LEVEL);\n\nproperty pr1;\n    @(posedge CLK) RST === 0 |-> ctrl_reg_d === 0;\nendproperty\n\nproperty pr2;\n    @(posedge CLK) disable iff (!RST) RST === 0 |-> cycle_cnt === 0;\nendproperty\n\n// ak je adresa mimo rozsah -> skontroluj v dalsom cykle vystavenie response OOR\n\n// Property pr3: Checks if an out-of-range address results in OOR response next cycle\n// Assuming CP_RSP_OOR is defined in sv_param_pkg\nproperty pr3;\n    @(posedge CLK)  (ADDRESS > 8\'h14) |-> ##1 (RESPONSE === CP_RSP_OOR);\nendproperty\n\n\n// counter register is not stable while waiting for IRQ\nsequence checkNotStable;\n    // cnt reg is not stable while waiting for IRQ\n    !$stable(cnt_reg_d) throughout (RST === RST_ACT_LEVEL && P_IRQ === 0);\nendsequence\n\n// mod nie je disabled\nproperty prStable;\n    @(posedge CLK) ctrl_reg_d != TIMER_CR_DISABLED |-> checkNotStable;\nendproperty\n\nproperty prUnknown;\n    @(posedge CLK) RST === !RST_ACT_LEVEL |-> (!$isunknown(ADDRESS)) && (!$isunknown(REQUEST) && (!$isunknown(RESPONSE)) && (!$isunknown(P_IRQ)));\nendproperty\n\nproperty prUnknownDataRead;\n    @(posedge CLK) (REQUEST === CP_REQ_READ)\n        |=> (!$isunknown((DATA_IN))) && (!$isunknown((DATA_OUT)));\nendproperty\n\nproperty prUnknownDataWrite;\n    @(posedge CLK) (REQUEST === CP_REQ_WRITE)\n        |-> (!$isunknown((DATA_IN))) && (!$isunknown((DATA_OUT)));\nendproperty\n\nproperty prReadWriteOOR;\n     @(posedge CLK) (REQUEST === CP_REQ_READ || REQUEST === CP_REQ_WRITE) && (ADDRESS > 8\'h14)\n        |-> ##1 (RESPONSE === CP_RSP_OOR);\nendproperty\n\nproperty prReadWriteUnaligned;\n     @(posedge CLK) (REQUEST === CP_REQ_READ || REQUEST === CP_REQ_WRITE) && (ADDRESS[1:0] != 2\'b00)\n        |-> ##1 (RESPONSE === CP_RSP_UNALIGNED);\nendproperty\n\nproperty checkWriteReadSameAddr;\n    logic [ADDR_WIDTH-1:0] v_addr;\n    logic [DATA_WIDTH-1:0] v_data;\n\n    @(posedge CLK)\n    ( (REQUEST === CP_REQ_WRITE),\n      v_addr = ADDRESS,\n      v_data = DATA_IN )\n    ##1\n    ( REQUEST === CP_REQ_READ && ADDRESS === v_addr )\n    |->\n    ##1\n    ( DATA_OUT === v_data );\nendproperty\n\nproperty ackAfterCorrectAddr;\n    @(posedge CLK)\n    ( (REQUEST === CP_REQ_READ || REQUEST === CP_REQ_WRITE) && ADDRESS <= 8\'h14 && ADDRESS[1:0] === 2\'b00)\n    |-> ##1\n    ( RESPONSE === CP_RSP_ACK );\nendproperty\n\nproperty idleResponseToNonReq;\n    @(posedge CLK)\n    ( (REQUEST === CP_REQ_NONE) )\n    |-> ##1\n    ( RESPONSE === CP_RSP_IDLE );\nendproperty\n\nproperty errorResponseToResReq;\n    @(posedge CLK)\n    ( (REQUEST === CP_REQ_RESERVED) )\n    |-> ##1\n    ( RESPONSE === CP_RSP_ERROR );\nendproperty\n\nproperty noWaitResponse;\n    @(posedge CLK) (RST === !RST_ACT_LEVEL) |-> !(RESPONSE === CP_RSP_WAIT);\nendproperty\n\nproperty irqAfterCmpCntMatch;\n    @(posedge CLK iff ctrl_reg_d != TIMER_CR_DISABLED) cnt_reg_d === cmp_reg_d\n        |-> ##1 (P_IRQ === 1);\nendproperty\n\nproperty clearCntAfterCmpCntMatchAutoRestart;\n    @(posedge CLK) ((cnt_reg_d === cmp_reg_d) && (ctrl_reg_d === TIMER_CR_AUTO_RESTART)\n        && !((REQUEST == CP_REQ_WRITE && DATA_IN != TIMER_CR_DISABLED)))\n        |-> ##1 ( cnt_reg_d === 0 );\nendproperty\n\n// does not apply if:\n//      we are changing mode\n//      OR we are writing another value to CNT\nproperty incCntAfterCmpCntMatchContinuous;\n    @(posedge CLK) ((cnt_reg_d === cmp_reg_d) && (ctrl_reg_d === TIMER_CR_CONTINUOUS)\n        && !((REQUEST == CP_REQ_WRITE && ADDRESS == TIMER_CR && DATA_IN != TIMER_CR_DISABLED) || (REQUEST == CP_REQ_WRITE && ADDRESS == TIMER_CNT)) )\n        |-> ##1 ( cnt_reg_d === $past(cnt_reg_d) + 1 );\nendproperty\n\nproperty clearCntDisAfterCmpCntMatchOneShot;\n    @(posedge CLK) ((cnt_reg_d === cmp_reg_d) && (ctrl_reg_d === TIMER_CR_ONESHOT)\n        && !((REQUEST == CP_REQ_WRITE && DATA_IN != TIMER_CR_DISABLED)) )\n        |-> ##1 (cnt_reg_d === 0 && ctrl_reg_d === TIMER_CR_DISABLED);\nendproperty\n\nproperty cycleLRead;\n    @(posedge CLK) (ADDRESS === TIMER_CYCLE_L && REQUEST === CP_REQ_READ)\n        |-> ##1 (DATA_OUT === cycle_cnt[31:0]);\nendproperty\n\nproperty cycleHRead;\n    @(posedge CLK) (ADDRESS === TIMER_CYCLE_H && REQUEST === CP_REQ_READ)\n        |-> ##1 (DATA_OUT === cycle_cnt[63:32]);\nendproperty\n\nproperty cycleCntZeroDuringReset;\n    @(posedge CLK) (RST === RST_ACT_LEVEL)\n        |-> ##1 (cycle_cnt === 0);\nendproperty\n\n\n\n// --- Assertions ---\n\nResetCtrlRegCheck: assert property (pr1)\nelse\n    // Fail action block\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion pr1 FAILED: ctrl_reg_d not reset correctly when RST === 0.\")\n    end\n\nResetCycleCntCheck: assert property (pr2)\nelse\n    // Fail action block\n    begin\n        // Using fatal as in the original code\n        `uvm_error(\"ABV_TIMER_ASSERT\", \"Assertion pr2 FAILED: cycle_cnt not reset correctly when RST === 0.\")\n    end\n\n// You defined pr3 but didn\'t assert it, let\'s add it:\nAddrRangeCheck: assert property (pr3)\nelse\n    // Fail action block\n    begin\n        `uvm_error(\"ABV_TIMER_ASSERT\", $sformatf(\"Assertion pr3 FAILED: OOR Address 0x%0h did not trigger OOR response (RESPONSE = %0d).\", ADDRESS, RESPONSE))\n    end\n\n// SignalsStableWhenNotDisabled: assert property(prStable)\n// else\n//     // Fail action block\n//     begin\n//         // Using fatal as in the original code\n//         `uvm_error(\"SignalsStableWhenNotUnknown\", \"Assertion prStable FAILED: Signals stable when mode not disabled.\")\n//     end\n\nSignalsDefined: assert property(prUnknown)\nelse\n    // Fail action block\n    begin\n        // Using fatal as in the original code\n        `uvm_error(\"InputSignalNotUnknown\", \"Assertion prUnknown FAILED: DATA_IN and DATA_OUT are unknown.\")\n    end\n\n// a   prUnknownDataRead\na_prUnknownDataRead: assert property (prUnknownDataRead) else $error(\"ACK did not follow REQ within 2 cycles\");\n\n// a   prUnknownDataWrite\na_prUnknownDataWrite: assert property (prUnknownDataWrite) else $error(\"ACK did not follow REQ within 2 cycles\");\n\n// a+c prReadOOR\na_prReadWriteOOR: assert property (prReadWriteOOR) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_prReadWriteOOR: cover property (prReadWriteOOR) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\n// a+c prReadWriteUnaligned\na_prReadWriteUnaligned: assert property (prReadWriteUnaligned) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_prReadWriteUnaligned: cover property (prReadWriteUnaligned) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\n// a+c checkWriteReadSameAddr\na_checkWriteReadSameAddr: assert property (checkWriteReadSameAddr) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_checkWriteReadSameAddr: cover property (checkWriteReadSameAddr) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\n// a+c ackAfterCorrectAddr\na_ackAfterCorrectAddr: assert property (ackAfterCorrectAddr) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_ackAfterCorrectAddr: cover property (ackAfterCorrectAddr) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\n// a+c idleResponseToNonReq\na_idleResponseToNonReq: assert property (idleResponseToNonReq) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_idleResponseToNonReq: cover property (idleResponseToNonReq) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\na_errorResponseToResReq: assert property (errorResponseToResReq) else $error(\"ACK did not follow REQ within 2 cycles\");\n// a   noWaitResponse\na_noWaitResponse: assert property (noWaitResponse) else $error(\"ACK did not follow REQ within 2 cycles\");\n\n// a+c irqAfterCmpCntMatch\na_irqAfterCmpCntMatch: assert property (irqAfterCmpCntMatch) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_irqAfterCmpCntMatch: cover property (irqAfterCmpCntMatch) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\n// a+c clearCntAfterCmpCntMatchAutoRestart\na_clearCntAfterCmpCntMatchAutoRestart: assert property (clearCntAfterCmpCntMatchAutoRestart) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_clearCntAfterCmpCntMatchAutoRestart: cover property (clearCntAfterCmpCntMatchAutoRestart) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\n// a+c incCntAfterCmpCntMatchContinuous\na_incCntAfterCmpCntMatchContinuous: assert property (incCntAfterCmpCntMatchContinuous) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_incCntAfterCmpCntMatchContinuous: cover property (incCntAfterCmpCntMatchContinuous) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\n// a+c clearCntDisAfterCmpCntMatchOneShot\na_clearCntDisAfterCmpCntMatchOneShot: assert property (clearCntDisAfterCmpCntMatchOneShot) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_clearCntDisAfterCmpCntMatchOneShot: cover property (clearCntDisAfterCmpCntMatchOneShot) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\n// a+c cycleLRead\na_cycleLRead: assert property (cycleLRead) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_cycleLRead: cover property (cycleLRead) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\n// a+c cycleHRead\na_cycleHRead: assert property (cycleHRead) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_cycleHRead: cover property (cycleHRead) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\n// a+c cycleCntZeroDuringReset\na_cycleCntZeroDuringReset: assert property (cycleCntZeroDuringReset) else $error(\"ACK did not follow REQ within 2 cycles\");\nc_cycleCntZeroDuringReset: cover property (cycleCntZeroDuringReset) $info(\"Correct REQ/ACK sequence observed\"); // Keep cover info\n\n\nendmodule : abv_timer\n","lang":"verilog"};
processSrcData(g_data);
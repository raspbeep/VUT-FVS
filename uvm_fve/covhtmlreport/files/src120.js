var g_data = {"name":"agents/./coverage.svh","src":"// This class measures exercised combinations of DUTs interface ports.\nclass timer_t_coverage extends uvm_subscriber #(timer_t_transaction);\n\n    // registration of component tools\n    `uvm_component_utils( timer_t_coverage )\n\n    // member attributes\n    local T m_transaction_h;\n    virtual dut_internal_if ivif;\n\n    // Covergroup definition\n    covergroup FunctionalCoverage( string inst );\n        // 1 Coverpoint a biny pro módy timeru, abychom měli jistotu, že se každý mód aktivoval alespoň jednou. Váha 0 (pomocný coverpoint pro cross).\n        modes: coverpoint ivif.ctrl_reg_d {\n            bins disabled = { TIMER_CR_DISABLED };\n            bins auto_restart = { TIMER_CR_AUTO_RESTART };\n            bins oneshot = { TIMER_CR_ONESHOT };\n            bins continuous = { TIMER_CR_CONTINUOUS };\n            option.weight = 0;\n        }\n\n        // 2 Coverpoint a biny pro povolené operace (REQUEST = write, read, none, hodnota RESERVED by měla být ignorována). Váha 0 (pomocný coverpoint pro cross).\n        request: coverpoint m_transaction_h.REQUEST {\n            bins req_none = { CP_REQ_NONE };\n            bins req_read = { CP_REQ_READ };\n            bins req_write = { CP_REQ_WRITE };\n            option.weight = 0;\n        }\n\n        // 3 Coverpoint a biny pro hodnoty 0 a 1 signálu reset.\n        reset: coverpoint m_transaction_h.RST {\n            bins active = { 0 };\n            bins inactive = { 1 };\n        }\n\n        // 4 Transition coverpoint pro přechody na signálu reset: 0->1, 1->0. Každý přechod musí nastat alespoň 5x.\n        cv4: coverpoint m_transaction_h.RST {\n            bins transitions[] = (0=>1), (1=>0);\n            option.at_least = 5;\n        }\n\n        // 5 Coverpoint a biny pro adresy 8\'h0, 8\'h4, 8\'h8, 8\'h10, 8\'h14. Váha 0 (pomocný coverpoint pro cross). \n        addresses: coverpoint m_transaction_h.ADDRESS {\n            bins all_modes[] = { TIMER_CNT, TIMER_CMP, TIMER_CR, TIMER_CYCLE_L, TIMER_CYCLE_H };\n            option.weight = 0;\n        }\n\n        // 6 Cross coverpoint všech adres (můžete použít coverpoint z 5.), operace write, a neaktivního resetu (můžete použít coverpoint z 3. a omezit se na neaktivní reset).\n        cv6: cross request, reset, addresses {\n            bins all_addr_write_no_rst = binsof(addresses) && binsof(reset.inactive) && binsof(request.req_write);\n        }\n\n        // 7 Cross coverpoint všech adres (můžete použít coverpoint z 5.), operace read, a neaktivního resetu (můžete použít coverpoint z 3. a omezit se na neaktivní reset).\n        cv7: cross request, reset, addresses {\n            bins all_addr_write_no_rst = binsof(addresses) && binsof(reset.inactive) && binsof(request.req_read);\n        }\n\n        // 8 Coverpoint a biny pro hodnoty 0 a 1 signálu přerušení.\n        irq: coverpoint m_transaction_h.P_IRQ {\n            bins irq_active   = { 1 };\n            bins irq_inactive = { 0 };\n        }\n        \n        // 9 Transition coverpoint pro přechody na signálu přerušení: 0->1, 1->0. Každý přechod musí nastat alespoň 10x.\n        cv9: coverpoint m_transaction_h.P_IRQ {\n            bins transitions[] = (0=>1), (1=>0);\n            option.at_least = 10;\n        }\n\n        // 10 Cross coverpoint pro aktivní přerušení ve všech módech (kromě DISABLED).\n        cv10: cross modes, irq {\n            bins auto_restart = binsof(modes.auto_restart) && binsof(irq.irq_active);\n            bins oneshot = binsof(modes.oneshot) && binsof(irq.irq_active);\n            bins continuous = binsof(modes.continuous) && binsof(irq.irq_active);\n        }\n\n        // 11 Transition coverpoint pro přechody mezi módy, tzn. např. z módu ONE_SHOT do DISABLED, z DISABLED do AUTO_RESTART atd.\n        all_modes_transitions: coverpoint ivif.ctrl_reg_d {\n            bins transitions[] = ([TIMER_CR_DISABLED:TIMER_CR_CONTINUOUS] => [TIMER_CR_DISABLED:TIMER_CR_CONTINUOUS]), \n                                ([TIMER_CR_CONTINUOUS:TIMER_CR_DISABLED] => [TIMER_CR_CONTINUOUS:TIMER_CR_DISABLED]);\n            option.at_least = 10;\n        }\n\n        // 12 Cross coverpoint všech adres, všech operací kromě RESERVED (můžete použít coverpoint z 2.),\n        // neaktivního resetu (můžete použít coverpoint z 3. a omezit se na neaktivní reset), a všech módů\n        // (můžete použít coverpoint z 1).\n        cv12: cross addresses, request, reset, modes {\n            bins all = binsof(addresses) && binsof(request) && binsof(reset.inactive) && binsof(modes);\n        }\n    endgroup\n\n    // Constructor - creates new instance of this class\n    function new( string name = \"m_coverage_h\", uvm_component parent = null );\n        super.new( name, parent );\n        FunctionalCoverage = new( \"timer\" );\n    endfunction: new\n\n    // Build - instantiates child components\n    function void build_phase( uvm_phase phase );\n        super.build_phase( phase );\n        if ( !uvm_config_db #(virtual dut_internal_if)::get(this,\n            \"*\", \"dut_internal_if\", ivif) ) begin\n            `uvm_fatal( \"configuration:\", \"Cannot find \'dut_internal_if\' inside uvm_config_db, probably not set!\" )\n        end\n    endfunction: build_phase\n\n    // Write - obligatory function, samples value on the interface.\n    function void write( T t );\n        // skip invalid transactions\n        m_transaction_h = t;\n        FunctionalCoverage.sample();\n    endfunction: write\n\nendclass: timer_t_coverage\n","lang":"verilog"};
processSrcData(g_data);